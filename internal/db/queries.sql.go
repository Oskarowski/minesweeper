// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const createGame = `-- name: CreateGame :one
INSERT INTO
    games (grid_size, mines_amount, grid_state)
VALUES
    (?, ?, ?) RETURNING id, uuid, grid_size, mines_amount, game_failed, game_won, grid_state, created_at
`

type CreateGameParams struct {
	GridSize    int64
	MinesAmount int64
	GridState   string
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.GridSize, arg.MinesAmount, arg.GridState)
	var i Game
	err := row.Scan(
		&i.Id,
		&i.Uuid,
		&i.GridSize,
		&i.MinesAmount,
		&i.GameFailed,
		&i.GameWon,
		&i.GridState,
		&i.CreatedAt,
	)
	return i, err
}

const getGameById = `-- name: GetGameById :one
SELECT
    id, uuid, grid_size, mines_amount, game_failed, game_won, grid_state, created_at
FROM
    games
WHERE
    id = ?
`

func (q *Queries) GetGameById(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameById, id)
	var i Game
	err := row.Scan(
		&i.Id,
		&i.Uuid,
		&i.GridSize,
		&i.MinesAmount,
		&i.GameFailed,
		&i.GameWon,
		&i.GridState,
		&i.CreatedAt,
	)
	return i, err
}

const getGameByUuid = `-- name: GetGameByUuid :one
SELECT
    id, uuid, grid_size, mines_amount, game_failed, game_won, grid_state, created_at
FROM
    games
WHERE
    uuid = ?
`

func (q *Queries) GetGameByUuid(ctx context.Context, uuid string) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGameByUuid, uuid)
	var i Game
	err := row.Scan(
		&i.Id,
		&i.Uuid,
		&i.GridSize,
		&i.MinesAmount,
		&i.GameFailed,
		&i.GameWon,
		&i.GridState,
		&i.CreatedAt,
	)
	return i, err
}

const getGamesByMonthYearGroupedByDay = `-- name: GetGamesByMonthYearGroupedByDay :many
SELECT 
    strftime('%d', created_at) AS day, 
    COUNT(*) AS games_played
FROM games
WHERE created_at >= ? AND created_at < ?
GROUP BY day
ORDER BY day
`

type GetGamesByMonthYearGroupedByDayParams struct {
	CreatedAt   sql.NullTime
	CreatedAt_2 sql.NullTime
}

type GetGamesByMonthYearGroupedByDayRow struct {
	Day         interface{}
	GamesPlayed int64
}

func (q *Queries) GetGamesByMonthYearGroupedByDay(ctx context.Context, arg GetGamesByMonthYearGroupedByDayParams) ([]GetGamesByMonthYearGroupedByDayRow, error) {
	rows, err := q.db.QueryContext(ctx, getGamesByMonthYearGroupedByDay, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesByMonthYearGroupedByDayRow
	for rows.Next() {
		var i GetGamesByMonthYearGroupedByDayRow
		if err := rows.Scan(&i.Day, &i.GamesPlayed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGamesInfo = `-- name: GetGamesInfo :one
SELECT 
    COUNT(*) AS total_games,
    COUNT(*) FILTER (WHERE game_won = TRUE) AS won_games,
    COUNT(*) FILTER (WHERE game_failed = TRUE AND game_won = FALSE) AS lost_games,
    COUNT(*) FILTER (WHERE game_failed = FALSE AND game_won = FALSE) AS not_finished_games
FROM 
    games
`

type GetGamesInfoRow struct {
	TotalGames       int64
	WonGames         int64
	LostGames        int64
	NotFinishedGames int64
}

func (q *Queries) GetGamesInfo(ctx context.Context) (GetGamesInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getGamesInfo)
	var i GetGamesInfoRow
	err := row.Scan(
		&i.TotalGames,
		&i.WonGames,
		&i.LostGames,
		&i.NotFinishedGames,
	)
	return i, err
}

const getGamesInfoByUuids = `-- name: GetGamesInfoByUuids :one
SELECT 
    COUNT(*) AS total_games,
    COUNT(*) FILTER (WHERE game_won = TRUE) AS won_games,
    COUNT(*) FILTER (WHERE game_failed = TRUE AND game_won = FALSE) AS lost_games,
    COUNT(*) FILTER (WHERE game_failed = FALSE AND game_won = FALSE) AS not_finished_games
FROM 
    games
WHERE 
    uuid IN (/*SLICE:uuids*/?)
`

type GetGamesInfoByUuidsRow struct {
	TotalGames       int64
	WonGames         int64
	LostGames        int64
	NotFinishedGames int64
}

func (q *Queries) GetGamesInfoByUuids(ctx context.Context, uuids []string) (GetGamesInfoByUuidsRow, error) {
	query := getGamesInfoByUuids
	var queryParams []interface{}
	if len(uuids) > 0 {
		for _, v := range uuids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:uuids*/?", strings.Repeat(",?", len(uuids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:uuids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var i GetGamesInfoByUuidsRow
	err := row.Scan(
		&i.TotalGames,
		&i.WonGames,
		&i.LostGames,
		&i.NotFinishedGames,
	)
	return i, err
}

const getGamesPlayedPerGridSize = `-- name: GetGamesPlayedPerGridSize :many
SELECT grid_size, COUNT(*) AS games_played
FROM games
GROUP BY grid_size
ORDER BY grid_size
`

type GetGamesPlayedPerGridSizeRow struct {
	GridSize    int64
	GamesPlayed int64
}

func (q *Queries) GetGamesPlayedPerGridSize(ctx context.Context) ([]GetGamesPlayedPerGridSizeRow, error) {
	rows, err := q.db.QueryContext(ctx, getGamesPlayedPerGridSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGamesPlayedPerGridSizeRow
	for rows.Next() {
		var i GetGamesPlayedPerGridSizeRow
		if err := rows.Scan(&i.GridSize, &i.GamesPlayed); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMinesPopularity = `-- name: GetMinesPopularity :many
SELECT mines_amount, COUNT(*) AS mines_count
FROM games
GROUP BY mines_amount
ORDER BY mines_amount
`

type GetMinesPopularityRow struct {
	MinesAmount int64
	MinesCount  int64
}

func (q *Queries) GetMinesPopularity(ctx context.Context) ([]GetMinesPopularityRow, error) {
	rows, err := q.db.QueryContext(ctx, getMinesPopularity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMinesPopularityRow
	for rows.Next() {
		var i GetMinesPopularityRow
		if err := rows.Scan(&i.MinesAmount, &i.MinesCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovesByGameId = `-- name: GetMovesByGameId :many
SELECT
    id, game_id, move_type, "row", col, create_at
FROM
    moves
WHERE
    game_id = ?
`

func (q *Queries) GetMovesByGameId(ctx context.Context, gameID int64) ([]Move, error) {
	rows, err := q.db.QueryContext(ctx, getMovesByGameId, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Move
	for rows.Next() {
		var i Move
		if err := rows.Scan(
			&i.Id,
			&i.GameId,
			&i.MoveType,
			&i.Row,
			&i.Col,
			&i.CreateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalGamesCount = `-- name: GetTotalGamesCount :one
SELECT
    COUNT(id) as count
FROM
    games
`

func (q *Queries) GetTotalGamesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalGamesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertMove = `-- name: InsertMove :one
INSERT INTO
    moves (game_id, move_type, row, col)
VALUES
    (?, ?, ?, ?) RETURNING id, game_id, move_type, "row", col, create_at
`

type InsertMoveParams struct {
	GameId   int64
	MoveType string
	Row      int64
	Col      int64
}

func (q *Queries) InsertMove(ctx context.Context, arg InsertMoveParams) (Move, error) {
	row := q.db.QueryRowContext(ctx, insertMove,
		arg.GameId,
		arg.MoveType,
		arg.Row,
		arg.Col,
	)
	var i Move
	err := row.Scan(
		&i.Id,
		&i.GameId,
		&i.MoveType,
		&i.Row,
		&i.Col,
		&i.CreateAt,
	)
	return i, err
}

const listGames = `-- name: ListGames :many
SELECT
    id, uuid, grid_size, mines_amount, game_failed, game_won, created_at
FROM
    games
ORDER BY
    created_at DESC
LIMIT ? OFFSET ?
`

type ListGamesParams struct {
	Limit  int64
	Offset int64
}

type ListGamesRow struct {
	Id          int64
	Uuid        string
	GridSize    int64
	MinesAmount int64
	GameFailed  bool
	GameWon     bool
	CreatedAt   sql.NullTime
}

func (q *Queries) ListGames(ctx context.Context, arg ListGamesParams) ([]ListGamesRow, error) {
	rows, err := q.db.QueryContext(ctx, listGames, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGamesRow
	for rows.Next() {
		var i ListGamesRow
		if err := rows.Scan(
			&i.Id,
			&i.Uuid,
			&i.GridSize,
			&i.MinesAmount,
			&i.GameFailed,
			&i.GameWon,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameGridStateById = `-- name: UpdateGameGridStateById :exec
UPDATE
    games
SET
    game_failed = ?,
    game_won = ?,
    grid_state = ?
WHERE
    id = ?
`

type UpdateGameGridStateByIdParams struct {
	GameFailed bool
	GameWon    bool
	GridState  string
	Id         int64
}

func (q *Queries) UpdateGameGridStateById(ctx context.Context, arg UpdateGameGridStateByIdParams) error {
	_, err := q.db.ExecContext(ctx, updateGameGridStateById,
		arg.GameFailed,
		arg.GameWon,
		arg.GridState,
		arg.Id,
	)
	return err
}
